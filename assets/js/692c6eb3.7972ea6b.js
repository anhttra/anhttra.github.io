"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[571],{827:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>h,default:()=>x,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"Python - Basics/python-operator-magic-methods","title":"Operator Magic Methods","description":"In Python, methods starting and ending with double underscores \'\\\\\\\\\' are called Magic methods or Dunder methods (Double Under). These methods are widely used for operator overloading. [1]","source":"@site/tutorial/Python - Basics/python-operator-magic-methods.md","sourceDirName":"Python - Basics","slug":"/Python - Basics/python-operator-magic-methods","permalink":"/docs/Python - Basics/python-operator-magic-methods","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Python - Basics","permalink":"/docs/category/python---basics"}}');var d=r(4848),t=r(8453);const i={sidebar_position:1},h="Operator Magic Methods",c={},l=[{value:"Operator Overloading",id:"operator-overloading",level:2},{value:"References",id:"references",level:2}];function o(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"operator-magic-methods",children:"Operator Magic Methods"})}),"\n",(0,d.jsx)(s.p,{children:"In Python, methods starting and ending with double underscores '__' are called Magic methods or Dunder methods (Double Under). These methods are widely used for operator overloading. [1]"}),"\n",(0,d.jsx)(s.h2,{id:"operator-overloading",children:"Operator Overloading"}),"\n",(0,d.jsxs)(s.p,{children:["Here is the table of the most common operator megic methods in Python (",(0,d.jsx)(s.em,{children:"self"})," and ",(0,d.jsx)(s.em,{children:"x"})," refer to the same object):"]}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Method Definition"}),(0,d.jsx)(s.th,{children:"Operator"}),(0,d.jsx)(s.th,{children:"Description"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__add__(self, y)"})}),(0,d.jsx)(s.td,{children:"x + y"}),(0,d.jsxs)(s.td,{children:["The addition of two objects. The type of ",(0,d.jsx)(s.em,{children:"x"})," determines which add operator is called."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__contains__(self, y)"})}),(0,d.jsx)(s.td,{children:"y in x"}),(0,d.jsxs)(s.td,{children:["When ",(0,d.jsx)(s.em,{children:"x"})," is a collection you can test to see if ",(0,d.jsx)(s.em,{children:"y"})," is in it."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__eq__(self, y)"})}),(0,d.jsx)(s.td,{children:"x == y"}),(0,d.jsxs)(s.td,{children:["Returns ",(0,d.jsx)(s.em,{children:"True"})," or ",(0,d.jsx)(s.em,{children:"False"})," depending on the values of ",(0,d.jsx)(s.em,{children:"x"})," and ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__ge__(self,y)"})}),(0,d.jsx)(s.td,{children:"x >= y"}),(0,d.jsxs)(s.td,{children:["Returns ",(0,d.jsx)(s.em,{children:"True"})," or ",(0,d.jsx)(s.em,{children:"False"})," depending on the values of ",(0,d.jsx)(s.em,{children:"x"})," and ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__getitem__(self,y)"})}),(0,d.jsx)(s.td,{children:"x[y]"}),(0,d.jsxs)(s.td,{children:["Returns the item at the ",(0,d.jsx)(s.em,{children:"y"}),"-th position in ",(0,d.jsx)(s.em,{children:"x"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__gt__(self,y)"})}),(0,d.jsx)(s.td,{children:"x > y"}),(0,d.jsxs)(s.td,{children:["Returns ",(0,d.jsx)(s.em,{children:"True"})," or ",(0,d.jsx)(s.em,{children:"False"})," depending on the values of ",(0,d.jsx)(s.em,{children:"x"})," and ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__hash__(self)"})}),(0,d.jsx)(s.td,{children:"hash(x)"}),(0,d.jsxs)(s.td,{children:["Returns an integral value for ",(0,d.jsx)(s.em,{children:"x"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__int__(self)"})}),(0,d.jsx)(s.td,{children:"int(x)"}),(0,d.jsxs)(s.td,{children:["Returns an integer representation of ",(0,d.jsx)(s.em,{children:"x"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__iter__(self)"})}),(0,d.jsx)(s.td,{children:"for v in x"}),(0,d.jsxs)(s.td,{children:["Returns an iterator object for the sequence ",(0,d.jsx)(s.em,{children:"x"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__le__(self,y)"})}),(0,d.jsx)(s.td,{children:"x <= y"}),(0,d.jsxs)(s.td,{children:["Returns ",(0,d.jsx)(s.em,{children:"True"})," or ",(0,d.jsx)(s.em,{children:"False"})," depending on the values of ",(0,d.jsx)(s.em,{children:"x"})," and ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__len__(self)"})}),(0,d.jsx)(s.td,{children:"len(x)"}),(0,d.jsxs)(s.td,{children:["Returns the size of ",(0,d.jsx)(s.em,{children:"x"})," where ",(0,d.jsx)(s.em,{children:"x"})," has some length attribute."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__mod__(self,y)"})}),(0,d.jsx)(s.td,{children:"x%y"}),(0,d.jsxs)(s.td,{children:["Returns the value of ",(0,d.jsx)(s.em,{children:"x"})," modulo ",(0,d.jsx)(s.em,{children:"y"}),". This is the remainder of ",(0,d.jsx)(s.em,{children:"x"}),"/",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__mul__(self,y)"})}),(0,d.jsx)(s.td,{children:"x*y"}),(0,d.jsxs)(s.td,{children:["Returns the product of ",(0,d.jsx)(s.em,{children:"x"})," and ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__ne__(self,y)"})}),(0,d.jsx)(s.td,{children:"x != y"}),(0,d.jsxs)(s.td,{children:["Returns ",(0,d.jsx)(s.em,{children:"True"})," or ",(0,d.jsx)(s.em,{children:"False"})," depending on the values of ",(0,d.jsx)(s.em,{children:"x"})," and ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__neg__(self)"})}),(0,d.jsx)(s.td,{children:"-x"}),(0,d.jsxs)(s.td,{children:["Returns the unary negation of ",(0,d.jsx)(s.em,{children:"x"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__repr__(self)"})}),(0,d.jsx)(s.td,{children:"repr(x)"}),(0,d.jsxs)(s.td,{children:["Returns a string version of ",(0,d.jsx)(s.em,{children:"x"})," suitable to be evaluated by the ",(0,d.jsx)(s.em,{children:"eval"})," function."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__setitem__(self,i,y)"})}),(0,d.jsx)(s.td,{children:"x[i] = y"}),(0,d.jsxs)(s.td,{children:["Sets the item at the ",(0,d.jsx)(s.em,{children:"i"}),"-th position in ",(0,d.jsx)(s.em,{children:"x"})," to ",(0,d.jsx)(s.em,{children:"y"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__str__(self)"})}),(0,d.jsx)(s.td,{children:"str(x)"}),(0,d.jsxs)(s.td,{children:["Return a string representation of ",(0,d.jsx)(s.em,{children:"x"})," suitable for user-level interaction."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"__sub__(self,y)"})}),(0,d.jsx)(s.td,{children:"x - y"}),(0,d.jsx)(s.td,{children:"The difference of two objects."})]})]})]}),"\n",(0,d.jsx)(s.p,{children:"Table 1: Python Operator Magic Methods [2]."}),"\n",(0,d.jsx)(s.h2,{id:"references",children:"References"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["[1] Dunder or magic methods in Python (",(0,d.jsx)(s.a,{href:"https://www.geeksforgeeks.org/dunder-magic-methods-python/",children:"https://www.geeksforgeeks.org/dunder-magic-methods-python/"}),")"]}),"\n",(0,d.jsx)(s.li,{children:"[2] Lee, Kent D., and Steve Hubbard. Data structures and algorithms with python. Second Edition, Springer Nature Switzerland AG 2024."}),"\n"]})]})}function x(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>i,x:()=>h});var n=r(6540);const d={},t=n.createContext(d);function i(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function h(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);